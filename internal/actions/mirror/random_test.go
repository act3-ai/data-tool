package mirror

import (
	"context"
	"encoding/json"
	"fmt"
	"math/rand"
	"testing"

	"github.com/opencontainers/image-spec/specs-go"
	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"oras.land/oras-go/v2"
	"oras.land/oras-go/v2/content"
	"oras.land/oras-go/v2/content/memory"
)

func pushRandomBlob(ctx context.Context, pusher content.Pusher, source rand.Source, mediaType string, platform *ocispec.Platform) (ocispec.Descriptor, error) {
	rng := rand.New(source) //nolint:gosec

	n := rng.Intn(100) + 1
	data := make([]byte, n)
	_, err := rng.Read(data)
	if err != nil {
		return ocispec.Descriptor{}, err
	}
	desc, err := oras.PushBytes(ctx, pusher, mediaType, data)
	if err != nil {
		return ocispec.Descriptor{}, err
	}
	if platform != nil {
		desc.Platform = platform
	}
	return desc, nil
}

func pushConfigBlob(ctx context.Context, pusher content.Pusher, source rand.Source, platform *ocispec.Platform) (ocispec.Descriptor, error) {
	rng := rand.New(source) //nolint:gosec
	n := rng.Intn(10) + 1
	d := make([]byte, n)
	_, err := rng.Read(d)
	if err != nil {
		return ocispec.Descriptor{}, err
	}
	cfg := ocispec.ImageConfig{
		// generate a random user to keep digests unique
		User: string(d),
	}
	data, err := json.Marshal(cfg)
	if err != nil {
		return ocispec.Descriptor{}, fmt.Errorf("marshalling empty config: %w", err)
	}
	desc, err := oras.PushBytes(ctx, pusher, "application/vnd.oci.image.config.v1+json", data)
	if err != nil {
		return ocispec.Descriptor{}, fmt.Errorf("pushing the config blob: %w", err)
	}
	desc.Platform = platform
	return desc, nil
}
func TestPushRandomBlob(t *testing.T) {
	ctx := context.Background()
	// cas := memory.New()

	t.Run("same", func(t *testing.T) {
		d1, err := pushRandomBlob(ctx, memory.New(), rand.NewSource(1), "", nil)
		require.NoError(t, err)

		d2, err := pushRandomBlob(ctx, memory.New(), rand.NewSource(1), "", nil)
		require.NoError(t, err)

		assert.Equal(t, d1.Digest, d2.Digest)
	})

	t.Run("different", func(t *testing.T) {
		d1, err := pushRandomBlob(ctx, memory.New(), rand.NewSource(1), "", nil)
		require.NoError(t, err)

		d2, err := pushRandomBlob(ctx, memory.New(), rand.NewSource(2), "", nil)
		require.NoError(t, err)

		assert.NotEqual(t, d1.Digest, d2.Digest)
	})

	t.Run("rng", func(t *testing.T) {
		rng := rand.New(rand.NewSource(1))
		d1, err := pushRandomBlob(ctx, memory.New(), rng, "", nil)
		require.NoError(t, err)

		d2, err := pushRandomBlob(ctx, memory.New(), rng, "", nil)
		require.NoError(t, err)

		assert.NotEqual(t, d1.Digest, d2.Digest)
	})
}

func pushRandomManifest(ctx context.Context, storage oras.Target, source rand.Source, subject *ocispec.Descriptor, tag string, platform *ocispec.Platform) (ocispec.Descriptor, error) {
	rng := rand.New(source) //nolint:gosec

	n := rng.Intn(4) + 2
	blobs := make([]ocispec.Descriptor, n)
	for i := range blobs {
		blob, err := pushRandomBlob(ctx, storage, rng, "", platform)
		if err != nil {
			return ocispec.Descriptor{}, err
		}
		blobs[i] = blob
	}
	var options oras.PackManifestOptions
	cfg, err := pushConfigBlob(ctx, storage, rng, platform)
	if err != nil {
		return ocispec.Descriptor{}, err
	}
	if subject != nil {
		options = oras.PackManifestOptions{
			Subject:          subject,
			Layers:           blobs,
			ConfigDescriptor: &cfg,
			ManifestAnnotations: map[string]string{
				// this timestamp will be automatically generated by oras.PackManifest() if not specified
				// use a fixed value here in order to have reproducible images
				ocispec.AnnotationCreated: "1970-01-01T00:00:00Z", // POSIX epoch
			},
		}
	} else {
		options = oras.PackManifestOptions{
			Layers:           blobs,
			ConfigDescriptor: &cfg,
			ManifestAnnotations: map[string]string{
				// this timestamp will be automatically generated by oras.PackManifest() if not specified
				// use a fixed value here in order to have reproducible images
				ocispec.AnnotationCreated: "1970-01-01T00:00:00Z", // POSIX epoch
			},
		}
	}

	// if platform != nil {
	// 	options.ConfigDescriptor = &ocispec.Descriptor{
	// 		MediaType: ocispec.MediaTypeImageConfig,
	// 		Platform:  platform,
	// 	}
	// } else {
	// 	options.ConfigDescriptor = &blobs[0]
	// }
	man, err := oras.PackManifest(ctx, storage, oras.PackManifestVersion1_1, "application/sample", options)
	if err != nil {
		return ocispec.Descriptor{}, err
	}

	if tag != "" {
		err = storage.Tag(ctx, man, tag)
		if err != nil {
			return ocispec.Descriptor{}, err
		}
	}

	if platform != nil {
		man.Platform = platform
	}

	return man, nil
}

func TestPushRandomManifest(t *testing.T) {
	ctx := context.Background()
	// cas := memory.New()

	t.Run("same", func(t *testing.T) {
		d1, err := pushRandomManifest(ctx, memory.New(), rand.NewSource(1), nil, "", nil)
		require.NoError(t, err)

		d2, err := pushRandomManifest(ctx, memory.New(), rand.NewSource(1), nil, "", nil)
		require.NoError(t, err)

		assert.Equal(t, d1.Digest, d2.Digest)
	})

	t.Run("different", func(t *testing.T) {
		d1, err := pushRandomManifest(ctx, memory.New(), rand.NewSource(1), nil, "", nil)
		require.NoError(t, err)

		d2, err := pushRandomManifest(ctx, memory.New(), rand.NewSource(2), nil, "", nil)
		require.NoError(t, err)

		assert.NotEqual(t, d1.Digest, d2.Digest)
	})
}

func pushRandomIndex(ctx context.Context, storage oras.Target, source rand.Source, tag string) (ocispec.Descriptor, error) {
	rng := rand.New(source) //nolint:gosec

	n := rng.Intn(4) + 2
	manifests := make([]ocispec.Descriptor, n)
	for i := range manifests {
		man, err := pushRandomManifest(ctx, storage, rng, nil, "", nil)
		if err != nil {
			return ocispec.Descriptor{}, err
		}
		manifests[i] = man
	}

	index := ocispec.Index{
		Versioned: specs.Versioned{
			SchemaVersion: 2,
		},
		MediaType: ocispec.MediaTypeImageIndex,
		Manifests: manifests,
	}

	b, err := json.Marshal(index)
	if err != nil {
		return ocispec.Descriptor{}, fmt.Errorf("error marshalling the index: %w", err)
	}

	idx, err := oras.PushBytes(ctx, storage, ocispec.MediaTypeImageIndex, b)
	if err != nil {
		return ocispec.Descriptor{}, fmt.Errorf("error pushing top-level index: %w", err)
	}

	if tag != "" {
		err = storage.Tag(ctx, idx, tag)
		if err != nil {
			return ocispec.Descriptor{}, err
		}
	}

	return idx, nil
}

func pushRandomMultiArchIndex(ctx context.Context, storage oras.Target, source rand.Source, tag string) (ocispec.Descriptor, error) {
	rng := rand.New(source) //nolint:gosec

	platforms := []*ocispec.Platform{
		{OS: "linux", Architecture: "amd64"},
		{OS: "linux", Architecture: "arm64"},
		{OS: "linux", Architecture: "arm64", Variant: "v8"},
		nil,
	}

	n := rng.Intn(4) + 2
	manifests := make([]ocispec.Descriptor, n)
	for i := range manifests {
		nn := rng.Intn(len(platforms)) - 1
		man, err := pushRandomManifest(ctx, storage, rng, nil, "", platforms[nn])
		if err != nil {
			return ocispec.Descriptor{}, err
		}
		manifests[i] = man
	}

	index := ocispec.Index{
		Versioned: specs.Versioned{
			SchemaVersion: 2,
		},
		MediaType: ocispec.MediaTypeImageIndex,
		Manifests: manifests,
	}

	b, err := json.Marshal(index)
	if err != nil {
		return ocispec.Descriptor{}, fmt.Errorf("error marshalling the index: %w", err)
	}

	idx, err := oras.PushBytes(ctx, storage, ocispec.MediaTypeImageIndex, b)
	if err != nil {
		return ocispec.Descriptor{}, fmt.Errorf("error pushing top-level index: %w", err)
	}

	if tag != "" {
		err = storage.Tag(ctx, idx, tag)
		if err != nil {
			return ocispec.Descriptor{}, err
		}
	}

	return idx, nil
}

func TestPushRandomIndex(t *testing.T) {
	ctx := context.Background()
	// cas := memory.New()

	t.Run("same", func(t *testing.T) {
		d1, err := pushRandomIndex(ctx, memory.New(), rand.NewSource(1), "")
		require.NoError(t, err)

		d2, err := pushRandomIndex(ctx, memory.New(), rand.NewSource(1), "")
		require.NoError(t, err)

		assert.Equal(t, d1.Digest, d2.Digest)
	})

	t.Run("different", func(t *testing.T) {
		d1, err := pushRandomIndex(ctx, memory.New(), rand.NewSource(1), "")
		require.NoError(t, err)

		d2, err := pushRandomIndex(ctx, memory.New(), rand.NewSource(2), "")
		require.NoError(t, err)

		assert.NotEqual(t, d1.Digest, d2.Digest)
	})
}

/*
// contains predecessors, index, manifests, artifacts, and blobs
// returns a set of named descriptors.
// "root" is the top level root descriptor.
// "manifest"
func pushRandomSet1(ctx context.Context, storage oras.Target, source rand.Source, tag string) (map[string]ocispec.Descriptor, map[string]string, error) {
	names := map[string]ocispec.Descriptor{}
	rng := rand.New(source)

	root, err := pushRandomIndex(ctx, memory.New(), rng, "")
	if err != nil {
		return nil, err
	}
	names["root"] = root

	if tag != "" {
		if err := storage.Tag(ctx, root, tag); err != nil {
			return nil, err
		}
	}

	return names, nil
}
*/
