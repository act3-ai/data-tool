package mirror

import (
	"context"
	"fmt"

	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
	"golang.org/x/sync/errgroup"
	"oras.land/oras-go/v2"
	"oras.land/oras-go/v2/registry"
	"oras.land/oras-go/v2/registry/remote"

	"gitlab.com/act3-ai/asce/data/tool/internal/mirror/encoding"
	"gitlab.com/act3-ai/asce/data/tool/internal/print"
	"gitlab.com/act3-ai/asce/data/tool/internal/ref"
	"gitlab.com/act3-ai/asce/data/tool/internal/ui"
	"gitlab.com/act3-ai/asce/go-common/pkg/logger"
)

// ScatterOptions specify the requirements to run the mirror scatter command.
type ScatterOptions struct {
	SubsetFile     string
	Src            oras.ReadOnlyGraphTarget
	SrcString      string
	SrcReference   registry.Reference
	MappingSpec    string
	Selectors      []string
	ConcurrentHTTP int
	RootUI         *ui.Task
	DryRun         bool
	Recursive      bool
	RepoFunc       func(context.Context, string) (*remote.Repository, error)
}

// Scatter will fetch the artifacts located in a target (generated by gather or deserialize) and distribute them according to the mapping spec.
func Scatter(ctx context.Context, opts ScatterOptions) error { //nolint:gocognit
	wt := &WorkTracker{}

	mapper, err := newMapper(opts.MappingSpec)
	if err != nil {
		return fmt.Errorf("error creating the mapper: %w", err)
	}

	desc, err := opts.Src.Resolve(ctx, opts.SrcReference.ReferenceOrDefault())
	if err != nil {
		return fmt.Errorf("fetching index: %w", err)
	}

	if !encoding.IsIndex(desc.MediaType) {
		return fmt.Errorf("index is required to scatter but found %s instead", desc.MediaType)
	}

	filters, err := parseFilters(opts.Selectors)
	if err != nil {
		return err
	}

	// subset is a map of images to scatter if a source file is defined in the action.
	subset, err := ProcessSourcesFile(ctx, opts.SubsetFile, nil, opts.ConcurrentHTTP)
	if err != nil {
		return fmt.Errorf("error processing the source file: %w", err)
	}

	// put the subset list into a map for easy searching
	subsetMap := createSourcesMap(subset)

	successors, err := encoding.Successors(ctx, opts.Src, desc)
	if err != nil {
		return fmt.Errorf("finding successors: %w", err)
	}

	g, gctx := errgroup.WithContext(ctx)
	g.SetLimit(opts.ConcurrentHTTP)
	n := len(successors)
	for manCounter, d := range successors {
		manNumber := manCounter + 1 // local copy
		g.Go(func() error {
			task := opts.RootUI.SubTask(fmt.Sprintf("artifact %d/%d", manNumber, n))
			defer task.Complete()

			if len(subset) != 0 {
				if _, exists := subsetMap[d.Annotations[ref.AnnotationSrcRef]]; !exists {
					return nil
				}
			}

			destinations, err := filterRefByLabelAndGenerateDestinations(d, filters, mapper)
			if err != nil {
				return err
			}

			var destCount int
			for _, destRef := range destinations {
				destCount++
				// todo add logr
				destTask := task.SubTask(fmt.Sprintf("destination %d/%d", destCount, len(destinations)))
				destTask.Infof("sending %s to %s", d.Annotations[ref.AnnotationSrcRef], destRef)
				if opts.DryRun {
					destTask.Complete()
					return nil
				}

				c, err := NewCopier(gctx, logger.FromContext(gctx), opts.SrcString, destRef, opts.Src, opts.SrcReference, d, nil, registry.Reference{}, opts.Recursive, nil, opts.RepoFunc)
				if err != nil {
					destTask.Complete()
					return err
				}

				c.options.PostCopy = func(ctx context.Context, desc ocispec.Descriptor) error {
					wt.Add(desc)
					return nil
				}

				if err := Copy(gctx, c); err != nil {
					destTask.Complete()
					return err
				}

				tag := c.destRef.ReferenceOrDefault()
				// Tag will work if `tag` is an actual tag or a digest
				if err := c.dest.Tag(ctx, d, tag); err != nil {
					destTask.Complete()
					return fmt.Errorf("tagging scattered image as %s: %w", tag, err)
				}

				destTask.Complete()
			}
			return nil
		})
	}
	if err := g.Wait(); err != nil {
		return err
	}
	opts.RootUI.Infof("%s pushed for %d blobs", print.Bytes(wt.transferred.Load()), wt.blobs.Load())
	return nil
}
