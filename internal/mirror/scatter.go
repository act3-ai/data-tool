package mirror

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"

	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
	"golang.org/x/sync/errgroup"
	"oras.land/oras-go/v2"
	"oras.land/oras-go/v2/content"
	"oras.land/oras-go/v2/registry"

	"git.act3-ace.com/ace/go-common/pkg/logger"
	"gitlab.com/act3-ai/asce/data/tool/internal/mirror/encoding"
	"gitlab.com/act3-ai/asce/data/tool/internal/print"
	"gitlab.com/act3-ai/asce/data/tool/internal/ref"
	"gitlab.com/act3-ai/asce/data/tool/internal/ui"
	reg "gitlab.com/act3-ai/asce/data/tool/pkg/registry"
)

// ScatterOptions specify the requirements to run the mirror scatter command.
type ScatterOptions struct {
	SubsetFile      string
	Source          content.ReadOnlyGraphStorage
	SourceDesc      ocispec.Descriptor
	SourceReference registry.Reference
	MappingSpec     string
	Selectors       []string
	ConcurrentHTTP  int
	RootUI          *ui.Task
	DryRun          bool
	Recursive       bool
	Targeter        reg.EndpointGraphTargeter
}

// Scatter will fetch the artifacts located in a target (generated by gather or deserialize) and distribute them according to the mapping spec.
func Scatter(ctx context.Context, opts ScatterOptions) error { //nolint:gocognit
	if !encoding.IsIndex(opts.SourceDesc.MediaType) {
		return fmt.Errorf("index is required to scatter but found %s instead", opts.SourceDesc.MediaType)
	}

	wt := &WorkTracker{}
	progress := opts.RootUI.SubTaskWithProgress("Scattering")
	defer progress.Complete()
	mapper, err := newMapper(opts.MappingSpec)
	if err != nil {
		return fmt.Errorf("error creating the mapper: %w", err)
	}

	data, err := content.FetchAll(ctx, opts.Source, opts.SourceDesc)
	if err != nil {
		return fmt.Errorf("fetching index: %w", err)
	}

	if !encoding.IsIndex(opts.SourceDesc.MediaType) {
		return fmt.Errorf("index is required to scatter but found %s instead", opts.SourceDesc.MediaType)
	}

	filters, err := parseFilters(opts.Selectors)
	if err != nil {
		return err
	}

	// subset is a map of images to scatter if a source file is defined in the action.
	subset, err := ProcessSourcesFile(ctx, opts.SubsetFile, nil, opts.ConcurrentHTTP)
	if err != nil {
		return fmt.Errorf("error processing the source file: %w", err)
	}

	// put the subset list into a map for easy searching
	subsetMap := createSourcesMap(subset)

	successors, err := encoding.Successors(ctx, opts.Source, opts.SourceDesc)
	if err != nil {
		return fmt.Errorf("finding successors: %w", err)
	}

	var idx ocispec.Index
	if err = json.Unmarshal(data, &idx); err != nil {
		return fmt.Errorf("unmarshalling index: %w", err)
	}
	totalSize := idx.Annotations[encoding.AnnotationLayerSizeDeduplicated]
	s, err := strconv.Atoi(totalSize)
	if err != nil {
		return fmt.Errorf("getting artifact size from annotations: %w", err)
	}
	progress.Update(0, int64(s))

	g, gctx := errgroup.WithContext(ctx)
	g.SetLimit(opts.ConcurrentHTTP)
	n := len(successors)
	for manCounter, d := range successors {
		manNumber := manCounter + 1 // local copy
		g.Go(func() error {
			task := opts.RootUI.SubTask(fmt.Sprintf("artifact %d/%d", manNumber, n))
			defer task.Complete()

			if len(subset) != 0 {
				if _, exists := subsetMap[d.Annotations[ref.AnnotationSrcRef]]; !exists {
					return nil
				}
			}

			destinations, err := filterRefByLabelAndGenerateDestinations(d, filters, mapper)
			if err != nil {
				return err
			}
			var destCount int
			for _, destName := range destinations {
				destCount++
				// todo add logr
				destTask := task.SubTask(fmt.Sprintf("destination %d/%d", destCount, len(destinations)))
				destTask.Infof("sending %s to %s", d.Annotations[ref.AnnotationSrcRef], destName)
				if opts.DryRun {
					destTask.Complete()
					return nil
				}

				destTarget, err := opts.Targeter.GraphTarget(ctx, destName)
				if err != nil {
					return fmt.Errorf("initializing destination graph target: %w", err)
				}

				// parse with endpoint resolution
				destRef, err := opts.Targeter.ParseEndpointReference(destName)
				if err != nil {
					return fmt.Errorf("parising destination reference: %w", err)
				}

				log := logger.FromContext(gctx)
				copyOpts := oras.CopyGraphOptions{
					MountFrom: mountFrom(opts.SourceReference, destRef),
					OnMounted: onMounted(log),
				}
				c, err := NewCopier(ctx, log, opts.Source, destTarget, d, opts.Recursive, nil, copyOpts)
				if err != nil {
					destTask.Complete()
					return err
				}

				c.options.PostCopy = func(ctx context.Context, desc ocispec.Descriptor) error {
					wt.Add(desc)
					progress.Update(int64(int(desc.Size)/len(destinations)), 0)
					return nil
				}

				if err := Copy(gctx, c); err != nil {
					destTask.Complete()
					return err
				}

				tag := destRef.ReferenceOrDefault()
				// Tag will work if `tag` is an actual tag or a digest
				if err := destTarget.Tag(ctx, d, tag); err != nil {
					destTask.Complete()
					return fmt.Errorf("tagging scattered image as %s: %w", tag, err)
				}

				destTask.Complete()
			}
			return nil
		})
	}
	if err := g.Wait(); err != nil {
		return err
	}
	opts.RootUI.Infof("%s pushed for %d blobs", print.Bytes(wt.transferred.Load()), wt.blobs.Load())
	return nil
}
