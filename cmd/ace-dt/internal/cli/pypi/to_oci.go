/* Test this with
podman run -d -p 127.0.0.1:5000:5000 docker.io/library/registry:2
go run ./cmd/ace-dt pypi to-oci localhost:5000/pypi pyzmq
*/

package pypi

import (
	"context"

	"github.com/spf13/cobra"

	"gitlab.com/act3-ai/asce/data/tool/cmd/ace-dt/internal/cli/internal/ui"
	"gitlab.com/act3-ai/asce/data/tool/internal/actions/pypi"
	"gitlab.com/act3-ai/asce/go-common/pkg/config"
)

// newToOCICmd creates a new cobra.Command for the pypi to-oci subcommand.
func newToOCICmd(base *pypi.Action) *cobra.Command {
	action := &pypi.ToOCI{Action: base}
	uiOptions := ui.Options{}

	cmd := &cobra.Command{
		Use:   "to-oci [-r file]... OCI-REPOSITORY [PROJECT]...",
		Short: "Fetch python packages from Python package indexes and upload to the OCI-REPOSITORY as OCI images",
		Long: `This command is used to populate a OCI registry with python distributions.  The data will be pulled from the python package indexes specified and uploaded directly to the OCI registry without being written to disk.  This command will not transfer the same file twice and is idempotent.
		
Python distributions (source distributions and binary wheel distributions) to be synced can be specified in a number of ways.
1. Specify the project name at the end of the command line.  Version specifiers such as numpy>=3.9.2 are not currently supported.  Use selectors instead.
	$ ace-dt pypi to-oci reg.example.com/my/pypi numpy scipy===1.11.1

2. Specify the requirements file.  Currently we only support simple project names (no version specifier) or pinned versions with "--hash" of the distributions.  This file can be easily generated by "poetry export".
	$ ace-dt pypi to-oci reg.example.com/my/pypi -r requirements.txt

An example requirements file looks like this and is fully compatible with PIP (just not feature complete).

fsspec==2022.8.2 ; python_version >= "3.8" and python_version < "3.11" \
	--hash=sha256:6374804a2c0d24f225a67d009ee1eabb4046ad00c793c3f6df97e426c890a1d9 \
	--hash=sha256:7f12b90964a98a7e921d27fb36be536ea036b73bf3b724ac0b0bd7b8e39c7c18
aiohttp

Labels selectors can be used to further limit the files to be synced.  See "ace-dt pypi labels" for more information`,
		Example: `This will pull numpy from pypi and upload it to reg.example.com/my/pypi
$ ace-dt pypi to-oci reg.example.com/my/pypi numpy -l 'version.major=1,version.minor=25,version.patch=0,python=pp39'

or with a requirements file
$ ace-dt pypi to-oci reg.example.com/my/pypi -r requirements.txt

To record failed requirements and continue through the errors
$ ace-dt pypi to-oci reg.example.com/my/pypi -r requirements.txt --continue --failed-requirements failed-requirements.txt
Then only try processing the failed requirements (skips all the successful entries in requirements.txt)
$ ace-dt pypi to-oci reg.example.com/my/pypi -r failed-requirements.txt
`,

		Args: cobra.MinimumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			ociRepo := args[0]
			return ui.RunUI(cmd.Context(), uiOptions, func(ctx context.Context) error {
				return action.Run(ctx, ociRepo, args[1:]...)
			})
		},
	}

	cmd.Flags().StringArrayVarP(&action.Selectors, "selector", "l", []string{}, "Provide selectors for which python/abi/platform should be fetched.")

	cmd.Flags().BoolVar(&action.DryRun, "dry-run", false, "Dry run by only determining what work needs to be done.  Does not modify the OCI registry.")

	cmd.Flags().BoolVar(&action.Reproducible, "reproducible", false, "Makes the uploaded artifacts have a consistent (reproducible) digest.  This removes timestamps.  As a result \"ace-dt pypi serve\" cannot provide efficient responses when If-Modified-Since requests are received.  The benefit is that this produces layers that are possibly better suited for mirroring.")

	cmd.Flags().BoolVar(&action.Clean, "clean", false, "Construct entirely new OCI artifacts.  Do not reuse anything from OCI for caching purposes.")

	cmd.Flags().StringVar(&action.IndexURL, "index-url",
		config.EnvOr("PIP_INDEX_URL", "https://pypi.org/simple"),
		"Base URL of the Python Package Index. This should point to a repository compliant with PEP 503 (the simple repository API).  This can also be set with the PIP_INDEX_URL environment variable.")

	cmd.Flags().StringArrayVar(&action.ExtraIndexURLs, "extra-index-url",
		config.EnvArrayOr("PIP_EXTRA_INDEX_URL", []string{}, " "),
		"Extra URLs of package indexes to use in addition to --index-url. Should follow the same rules as --index-url.  This can also be set with the PIP_EXTRA_INDEX_URL environment variable.")

	cmd.Flags().StringArrayVarP(&action.RequirementFiles, "requirement", "r", []string{},
		"PIP compliant requirement file.  Used to define what python projects are synced.")

	cmd.Flags().BoolVar(&action.IncludeExtras, "include-extras", false, "Include the extra packages from requirements as requirements as well.  This is not needed if the extra packages are already included as individual requirements.")

	cmd.Flags().BoolVar(&action.ContinueOnError, "continue", false, `Continue even if an error occurs in processing a Python project or distribution.  This is useful when combined with --failed-requirements to collect the failures in a way that can be used to process the erroneous entries.`)

	cmd.Flags().StringVar(&action.FailedRequirementsFile, "failed-requirements", "", `File path to write the requirements that failed to be transferred`)

	ui.AddOptionsFlags(cmd.Flags(), &uiOptions)

	return cmd
}
